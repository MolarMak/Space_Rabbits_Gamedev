# Space_Rabbits_Gamedev

<h3><b>Онлайн режим</b></h3>

<b>Задача</b>

Необхідно реалізувати можливість системи створювати ігрові кімнати, щоб гравці могли приєднатися до них, отримати однакові запитання, відслідковувати відповіді кожного із гравця і нараховувати бали відповідно до відповідей. 
Також система має вміти вираховувати результати гри між гравцями і видавати відповідно: виграш, програш або нічию між ними, відповідно до цього нараховувати ігрові бали.

<b>Рішення</b>

<i>Загальний підхід</i>

При першому запиті гравця на онлайн гру створювати запис стану гри, так звану ігрову «кімнату», у базу даних із посиланням на цього гравця, як учасника. Із кожним наступним гравцем, система має перевіряти усі доступні вільні місця у ігрових «кімнатах», що є попередньо створеними станами гри попередніми гравцями, і якщо є вільні місця, тобто коли до кімнати долучений лише один гравець, а не два, то додавати до кімнати другого. Якщо в момент часу, коли новий гравець створює запит на онлайн гру, немає жодного вільного місця у кімнатах, то створювати нову кімнату. 
Після створення і заповнення ігрової кімнати, далі за допомогою технології вебсокетів підтримувати постійний двусторонній зв'язок між сервером та гравцями.
Гравці відповідаючи на питання, роблять запит по каналу зв’язку і в цей час, стан гри у базі даних обновляється, усі оновлення розсилаються по каналам зв’язку всім гравцям.
Після завершення гри система визначає переможця, або нічию, нараховує бали та посилає повідомлення про закінчення гри усім гравцям. Після цього система від’єднує гравців від кімнати і видає запис про стан гри із бази даних. 

<i>Вирахування переможця</i>

Кожен із гравців отримує по 5 однакових, але абсолютно випадкових питань  із загального списку.  Вони можуть бути як правильними, так і не правильними. Якщо  питання правильне і гравець обирає «так» то він отримує 1 бал, якщо питання не правильне і гравець обирає «ні» то він також отримує 1 бал. У всіх інших випадках бали не нараховується. Під кінець, коли обидва гравці відповіли на свої запитання, бали підраховуються і гравці дізнаються результат: виграш, програш або нічия. Гравець, котрий набрав більшу кількість балів у підсумку,    отримує  виграш, менше – програш, а якщо обидва гравці набрали порівну то нічию. 

<i>Технічне рішення</i>

При розробці мульплеера ми використовували технологію вебсокетів. При приєднанні гравця в кімнату йому у відповідність ставиться Actor, потокобезпечний об'єкт, який знаходиться в Actor System, за фактом в пулл об'єктів, і може комунікувати з іншими Actors за допомогою передачі та отримання повідомлень. Таким чином, ми маємо практично наочно уявлення про архітектуру, як про систему, де користувачі представлені об'єктами і спілкуються між собою. Стану онлайн ігри в кожен момент часу оновлюється кожним з Actors (оновлюється запис в БД), а також передаються сполучення між Actors, які потрапляють до прив'язаному до нього користувачеві. 

<i>Переваги</i>

Потокобезпечна система, із зрозумілими абстракціями і методами комунікації між ними. Висока швидкість роботи і обробки запитів.

<i>Недоліки</i>

Можливість збоїв у вебсокет комунікації між клієнтом та сервером, що може призвести до ефекту “замороження” гри, коли система очікує повторного під’єднання клієнту.
 
<i>Проблеми, що виникли у ході їх рішення</i> 

Вебсокет з’єднання та багато можливих станів об’єкту ігрової кімнати створюють підвищенну складність до написання юніт та інтеграційних тестів, що призводить то зменшення темпів розробки та збільшує вірогідність допущення помилок. 
 
<h3><b>Синхронізація на клієнті</b></h3>

<b>Задача</b>

Була задача реалізувати синхронізацію бази фактів клієнта з версією що знаходиться на сервері. Це було необхідно для того аби при оновленні записів БД на сервері з метою акталізації інформації чи виправлення помилок, клієн мав змогу завантажити оновлені записи та зберегти до БД / замінити ними старі (при наявності)

<b>Рішення</b>

<i>Загальний підхід</i>

Дані у додатку зберігаються у SQLite базі данних, робота з якою здійснюється з домомогою системного ORM framework-а CoreData.
Усі факти зберігаються у екземпляри класу 'Fact' та пишуться у сховище. Кожен факт має версію. З кожним оновленням версія факту інкрементується. 
При старті додатку виконується пошук найстарішої версії фактів і запитом на сервері отримуємо список оновлених записів. Завантажуємо їх усі, зберігаємо у CoreData. 

<i>Технічне рішення</i>

Структура модельної частини що працює з CoreData:
 - Managed Object Context — контекст у якому "живуть" об'єкти, в контексті виконується операції запису та видалення
 - Persistent Store Coordinator — зберігає дані до Persistent Store
 - Managed Object Model — модель бази
 - Persistent Store — репозиторій де зберігаються дані

Для збереження фактів маємо класс Fact що наслідується від NSManagedObject, що має наступні атрибути:
 - id: Int64
 - fact: String
 - factVersion: Int64
 - falseFact: String
 - trueFact: String
При чому маємо Constraint по id - при записі нового факту з таким самим id, новий запис буде затирати старий а отже не буде дублікатів і старих записів

Для читання фактів з БД використовуємо NSFetchRequest-ы. Для отримання записів що відповідають певним критеріям, використаємо такі функції CoreData:
 - fetchLimit: Int - для обмеження к-ті записів що будуть отримані
 - fetchPredicate: NSFetchPredicate - для зчитування лише записів що відповідають ряду критеріїв (%KEY = %VALUE та подібне)
 - sortDescriptor: NSSortDescriptor - визначає порядок у якому будуть відсортовані записи

Наприклад для отримання найменшої версії фактів у БД, робимо fetch request з sort descriptor по зростанню id, fetch limit = 1

<i>Переваги</i>

Використання даного підходу для організації роботи БД, збереігання та читання фактів має багато переваг: 
 - Простота масштабування, оновлення схеми БД, міграцій
 - Досить висока швидкодія
 - Зручне API CoreData дозволяє швидко розробити складну систему зберігання даних

<i>Недоліки</i>

Як недолік можна визначити той факт що при перериванні оновлення якщо Managed Object-и з контексту БД не було збережено до Persistent Store, оновлення буде втрачено і доведеться заново завантажувати усі оновлені факти.

<i>Проблеми, що виникли у ході їх рішення</i>

Для вирішення вищеописаної проблеми можна оновлення виконувати частинами і час від часу зберігати контекст. Тоді при помилці передачі чи завершені роботи додатку, частина вже оновлених даних залишиться у БД. Проте оскільки оновлення не завершилося повністю то мінімальна версія факту залишилася незмінна і доведеться перезавантажувати усі записи заново. Для вирішення цієї проблеми можна передавати на сервер список застарілих фактів і отримувати лише ті що потрібно. 
